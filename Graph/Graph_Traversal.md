# 图

## 图的表示
图有两种常见的表示方式：二维数组(邻接矩阵)和链表(邻接表)。 邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，
矩阵是的row和col 表示的是1..n个点，矩阵中的1表示有连线，0表示没有连线。 
![image](https://github.com/chiewhui1113/AlgorithmNotes/assets/75370269/92b44f03-f89b-47f8-ba4b-c937e16332e3)

邻接表则是用数组和链表组成，并且只关系有边的空间
![image](https://github.com/chiewhui1113/AlgorithmNotes/assets/75370269/6700c2ef-9643-47e1-a584-4dfb2454feb6)


## 图的遍历
1. Depth First Search（DFS）
DFS就是直接访问下个节点，往广度访问，用Queue实现
  
2. Breath First Search（BFS）
BFS先把该节点的所有节点加进去，用Stack实现

## 最小生成树
1. 普里姆算法，主要解決最小生成树问题。

2. 克鲁斯卡尔算法，主要解决加权树的最小生成树问题。
按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。
构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，
并使森林中不产生回路，直至森林变成一棵树为止。

## 最短路径问题
1. 迪杰斯特拉算法
图中两个点的最短路径问题。通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径

2. 弗洛伊德算法
图中每个顶点到其他所有顶点的最短路径。弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做
被访问顶点，求出从每 一个顶点到其他顶点的最 短路径。
